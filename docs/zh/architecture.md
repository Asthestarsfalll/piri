# 架构设计

## 项目结构

项目采用模块化设计，便于扩展：

- `config.rs`: 配置管理模块
- `niri.rs`: Niri IPC 封装模块
- `commands.rs`: 命令处理系统
- `scratchpads.rs`: Scratchpads 功能实现
- `plugins/`: 插件系统目录
  - `mod.rs`: 插件系统核心
  - `empty.rs`: Empty 插件实现
  - `scratchpads.rs`: Scratchpads 插件实现
- `daemon.rs`: 守护进程管理
- `ipc.rs`: 进程间通信（用于客户端与守护进程通信）

## 工作原理

### 守护进程架构

Piri 使用守护进程架构来提供持续的服务。守护进程在后台运行，监听 niri 事件并执行相应的操作。

### IPC 通信

客户端通过 IPC 与守护进程通信，发送命令和接收响应。这允许在不重启守护进程的情况下执行操作。

### 插件系统

插件系统允许扩展功能。每个插件实现 `Plugin` trait，并在守护进程启动时自动加载。

#### 统一事件分发机制

Piri 使用统一的事件分发机制来优化性能和资源使用：

- **单一 Socket 连接**：所有基于事件的插件共享一个 niri 事件流 socket 连接，而不是每个插件单独连接
- **高效事件分发**：事件只读取一次，然后通过 channel 分发给所有需要处理事件的插件
- **智能事件过滤**：插件可以声明它们感兴趣的事件类型，只有相关的插件才会收到事件，避免不必要的处理
- **性能优化**：减少了 socket 连接数量，降低了系统资源消耗
- **易于扩展**：新的事件驱动插件只需实现 `handle_event` 和 `is_interested_in_event` 方法，无需管理自己的事件监听循环

这种设计确保了：
- 更好的资源利用（只有一个 socket 连接）
- 更高的事件处理效率（事件只读取一次，只分发给感兴趣的插件）
- 更简洁的插件代码（插件只需关注事件处理逻辑）
- 更好的性能（避免不关心事件的插件被调用）

